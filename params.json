{"name":"Moses","tagline":"Moses is a simple option parser for writing command line applications","body":"Moses\r\n=====\r\nMoses is a simple option/command parser for building command line applications in Ruby.\r\n![image](moses.png)\r\n\r\nGetting Started\r\n---------------\r\n\r\nInstallation with ruby-gems:\r\n\r\n    gem install moses\r\n\r\nInstallation with bundler:\r\n\r\n    gem 'moses', '0.1.5'\r\n\r\nCreating a Moses application\r\n----------------------------\r\n\r\nMoses is a module that you can include into any Ruby class to provide all the plumbing you need to write command line applications. Create the following directory structure for your application\r\n\r\n- bin\r\n  - myapp\r\n- lib\r\n  - myapp.rb\r\n- VERSION\r\n- HELP.md (or just HELP)\r\n\r\nCreate a class for your applications functionality:\r\n\r\n```rb\r\n  class MyApp\r\n    include Moses\r\n    commands :foo, :bar\r\n\r\n    def foo\r\n      # do stuff\r\n    end\r\n\r\n    def bar\r\n      # do stuff\r\n    end\r\n  end\r\n```\r\n\r\nThen all you need in your executable file is the following:\r\n\r\n```rb\r\n  #!/usr/bin/env ruby\r\n  $: << File.expand_path(File.join(File.dirname(__FILE__), \"../lib\"))\r\n  require 'myapp'\r\n  MyApp.new.run\r\n```\r\n\r\nThat's all you need to create a CLI app. You can now call your application like so:\r\n\r\n    myapp foo\r\n    myapp bar\r\n\r\nBy default, Moses will read the contents of the HELP.md (or HELP) file in the root of your project. This will be used to display your application instructions when passed the flags `-h` and `--help`\r\n\r\n    myapp -h\r\n    myapp --help\r\n\r\n Similarly, Moses will use the VERSION file with the `-v` and `--version` flags.\r\n\r\n     myapp -v\r\n     myapp --version\r\n\r\nYou may choose not to use `VERSION` or `HELP` files in your project and simply define corresponding methods that output what you want:\r\n\r\n```rb\r\ndef help\r\n  output.puts \"This is my help text\"\r\nend\r\n\r\ndef version\r\n  output.puts \"X.X.X\"\r\nend\r\n```\r\n\r\nCommands\r\n--------\r\n\r\nMoses treats the first non-flag argument passed to it as a command (sometimes referred to as sub-commands). A command is simply a method defined in your application class. To define a command, simply add a command definition to your class and implement a method of the same name:\r\n\r\n```rb\r\n  class MyApp\r\n    include Moses\r\n    commands :foo\r\n\r\n    def foo\r\n      # do stuff\r\n    end\r\n  end\r\n```\r\n\r\nThis will create a `foo` command that can be called from the command line: `myapp foo`\r\n\r\n### Default command\r\n\r\nSometimes you will want to create an application that has no \"sub-commands\" and will simply be called from the command line with options. To run a command by default, add a default_command definition to your class:\r\n\r\n```rb\r\n  class MyApp\r\n    include Moses\r\n    default_command :main\r\n\r\n    def main\r\n      # do stuff\r\n    end\r\n  end\r\n```\r\n\r\nIn the above example, the `main` method will execute whenever your application is run. Simply calling `myapp` from the command line will execute the `main` method.\r\n\r\n\r\nOptions\r\n-------\r\n\r\nMoses will parse any flags passed to your application that begin with one or two dashes. There are two basic types of flags, boolean and variable flags.\r\n\r\n### Boolean flags\r\n\r\nFlags which begin with one dash are treated as boolean flags. A boolean flag is basically an _ON_ switch:\r\n\r\n    myapp -x\r\n\r\nThe above will create an `:x` key in the `@options` hash that is true. Given the above switch, we could write code to handle that switch like so:\r\n\r\n```rb\r\n  if @options[:x]\r\n    # stuff here\r\n  end\r\n```\r\n\r\n### Variable flags\r\n\r\nFlags which begin with two dashes are slightly trickier than boolean flags. Variable flags can be either boolean or be passed a value. Variable flags will be treated as a boolean if no arguments are passed after them:\r\n\r\n    myapp --foo\r\n\r\nIn the above example the value of `@options[:foo]` will be true. However if an argument is passed after the flag, it will automatically be assigned as the value:\r\n\r\n    myapp --foo bar\r\n\r\nIn this case the value of `@options[:foo]` will be the string `bar`. The flag can still be treated as a boolean but it's adjacent argument can also be accessed as it's value:\r\n\r\n```rb\r\n  if @options[:foo]\r\n    x = @options[:foo] # bar\r\n  end\r\n```\r\n\r\n### Option commands\r\n\r\nIt's common to run a command as the result of an option being passed (ie. `-h` or `--help`). To run a command automatically when an option is passed, simply add an `option_commands` definition to your class:\r\n\r\n```rb\r\nclass MyApp\r\n  include Moses\r\n  option_commands({ :auto => :run_automatic })\r\n\r\n  def run_automatic\r\n    # automatically runs when --auto is passed\r\n  end\r\nend\r\n```\r\n\r\n_Note: When using `option_commands`, no other command will be run. If you wish to execute multiple commands based on an option, simply use the boolean flag._\r\n\r\nOutput\r\n------\r\n\r\nBy default Moses exposes `$stdout` through an `output` method. To output to the terminal, simply use `output.puts`:\r\n\r\n```rb\r\n  output.puts \"This will be output to STDOUT\"\r\n```\r\n\r\nTo substitute your own output, define an initializer that overwrites the `@output` variable:\r\n\r\n```rb\r\nclass MyApp\r\n  def initialize(output)\r\n    @output = output\r\n  end\r\nend\r\n\r\nMyApp.new(File.open('output.txt'))\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}